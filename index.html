<!DOCTYPE html>
<html prefix="" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="This is the personal website for Alessandro.">
<meta name="viewport" content="width=device-width">
<title>Alessandro Bolletta</title>
<link href="assets/css/rst.css" rel="stylesheet" type="text/css">
<link href="assets/css/code.css" rel="stylesheet" type="text/css">
<link href="assets/css/dark.css" rel="stylesheet" type="text/css">
<link href="assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Share+Tech+Mono" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="https://alexpacio.github.io/">
<link rel="icon" href="files/favicon.ico" sizes="16x16">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]--><link rel="prefetch" href="posts/lightweight-nodejs-background-job-scheduler/" type="text/html">
</head>
<body class="hack dark">

<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="container">
         
    <header id="header"><h1 id="brand"><a href="." title="Alessandro Bolletta" rel="home">

        <span id="blog-title">Alessandro Bolletta</span>
    </a></h1>

        

        
    <nav id="menu"><ul>
<li class="active"><a href=".">Home<span class="sr-only"> (active)</span></a></li>
                <li><a href="archive.html">Archive</a></li>
                <li><a href="files/cv.pdf">CV</a></li>
                <li><a href="pages/about/">About me</a></li>
                <li><a href="https://github.com/alexpacio">My Github</a></li>

    

    
    
    </ul></nav></header><main id="content"><div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/lightweight-nodejs-background-job-scheduler/" class="u-url">Building a Lightweight Node.js Background Job Scheduler: A Practical Solution for Simple Web Applications</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Alessandro Bolletta
            </span></p>
            <p class="dateline">
            <a href="posts/lightweight-nodejs-background-job-scheduler/" rel="bookmark">
            <time class="published dt-published" datetime="2024-10-10T12:00:00Z" itemprop="datePublished" title="2024-10-10 12:00">2024-10-10 12:00</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <section id="building-a-lightweight-node-js-background-job-scheduler"><h2>Building a Lightweight Node.js Background Job Scheduler</h2>
<p>As developers, we often come across situations where a fully-fledged background job system, with all its bells and whistles, might be overkill for our project needs. This was the case for me when I built a custom background job scheduler in <strong>TypeScript</strong> and <strong>Node.js</strong>, designed to handle essential tasks without the overhead of larger, more complex solutions.</p>
<section id="the-need-for-a-simple-solution"><h3>The Need for a Simple Solution</h3>
<p>My project involved a web application that required periodic background tasks, such as <strong>data synchronization</strong>, <strong>cleanup jobs</strong>, and <strong>basic system monitoring</strong>. While there are many mature background job frameworks available, most were too feature-heavy for what I needed. I wanted something small, efficient, and easy to integrate into my Docker-based setup, without introducing unnecessary complexity.</p>
<p>That’s when I decided to write my own scheduler—lean, concise, and perfect for simple backend apps or as a side container to complement larger web applications.</p>
</section><section id="the-custom-scheduler-small-but-effective"><h3>The Custom Scheduler: Small but Effective</h3>
<p>The goal was to create a <strong>minimalistic background job scheduler</strong> that could be easily run in a Docker container alongside the main web application. Written in <strong>TypeScript</strong> and <strong>Node.js</strong>, the solution is focused purely on executing periodic tasks with the least amount of code possible, while ensuring it’s flexible enough to be extended for future needs.</p>
<p>Unlike robust job schedulers like <strong>Bull</strong> or <strong>Agenda</strong>, my custom scheduler strips away non-essential features and focuses on what truly matters for small applications: <strong>reliability and ease of use</strong>. It supports scheduling jobs at specific intervals, retrying on failure, and executing scripts or commands as needed. By keeping the codebase concise, the scheduler can be easily maintained and quickly deployed.</p>
</section><section id="seamless-integration-into-docker"><h3>Seamless Integration into Docker</h3>
<p>The scheduler is designed to be packaged as a <strong>multi-layer Docker container</strong>. This approach allows me to include all the necessary <strong>CLI tools and backend executables</strong> in one place, ensuring that the container remains isolated but tightly integrated with the rest of the application.</p>
<p>This makes it an ideal <strong>sidecar container</strong> to handle tasks for a larger web application. Its small footprint ensures that it won’t introduce significant overhead, making it an excellent choice for environments where resources are limited, such as microservices architectures or smaller backend deployments.</p>
</section><section id="real-time-observability-telegram-bot-and-email-alerts"><h3>Real-Time Observability: Telegram Bot and Email Alerts</h3>
<p>One of the unique aspects of this project was adding easy <strong>observability</strong> and <strong>control</strong> via a <strong>Telegram bot</strong> and <strong>email notifications</strong>. While the scheduler itself is minimalistic, I wanted to ensure I had a convenient way to monitor job status and handle any failures without diving into logs or dashboards.</p>
<p>The Telegram bot integration allows me to start or stop jobs, check their status, and receive instant notifications when something goes wrong. This real-time control, paired with email alerts for periodic updates or error logs, ensures I stay informed even when the jobs are running in the background.</p>
</section><section id="perfect-for-small-scale-applications"><h3>Perfect for Small-Scale Applications</h3>
<p>This background job scheduler might not have the rich feature set of other established systems, but that’s exactly why it works so well in certain scenarios. For <strong>smaller applications</strong> or web services that don’t require a heavy-duty job queue, this solution offers a lightweight, easy-to-manage alternative. It handles the basics efficiently, making it perfect for production environments where <strong>simplicity</strong> and <strong>performance</strong> are crucial.</p>
</section><section id="final-thoughts"><h3>Final Thoughts</h3>
<p>Creating this custom background job scheduler has been a rewarding experience. It’s not meant to replace more feature-rich systems, but rather fill the gap for projects where adding complex tooling would be overkill. With a <strong>small and concise codebase</strong>, seamless <strong>Docker integration</strong>, and <strong>real-time observability</strong> via Telegram and email, this scheduler has become an invaluable part of my workflow.</p>
<p>If you're working on a small backend or need a side container to handle background jobs without the complexity of larger frameworks, this custom solution might be just what you're looking for.</p>
<p>If you're tackling a similar challenge in your project, I highly recommend to have a try with the Background Job scheduler: <a class="reference external" href="https://github.com/alexpacio/background-job-scheduler">https://github.com/alexpacio/background-job-scheduler</a></p>
</section></section>
</div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/python-k8s-api/" class="u-url">Full-fledged API + e2e tests + benchmark + IaC + Helm charts + more as an (interesting) exercise!</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Alessandro Bolletta
            </span></p>
            <p class="dateline">
            <a href="posts/python-k8s-api/" rel="bookmark">
            <time class="published dt-published" datetime="2024-09-22T14:19:03+02:00" itemprop="datePublished" title="2024-09-22 14:19">2024-09-22 14:19</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>Last week, I was contacted for a coding challenge. The project seemed interesting, so I decided to take it on. At the very least, I would learn something new, which I was eager to explore: Pulumi, k6, FastAPI and some fancy modern things that make you look like a cool dev!</p>
<p>The project involved creating a simple REST API in Python, which needed to be packaged with Helm, ready for deployment in a Kubernetes (K8s) cluster, and including all the essential tools required.</p>
<p><strong>Requirements</strong></p>
<ul class="simple">
<li><p>A Python REST API backend program. The choice of framework was up to me</p></li>
<li><p>Unit and e2e tests</p></li>
<li><p>Swagger/OpenAPI documentation</p></li>
<li><p>A CDK-like deployment script to automate the API’s dependencies: Terraform or Pulumi (for an AWS CDK-like experience). Since I was curious, I chose Pulumi</p></li>
<li><p>Backend API should store its state via AWS PaaS services. Either a real AWS account or an automated way to use Localstack, a tool that simulates AWS’s APIs in your local environment, would have worked</p></li>
<li><p>A Helm package to deploy the Kubernetes cluster</p></li>
<li><p>Health checking mechanisms</p></li>
<li><p>Scripts to tie everything together, making the cluster reproducible by following a series of steps outlined in a README file.</p></li>
<li><p>Horizontal autoscaling</p></li>
<li><p>Built-in application benchmarking</p></li>
</ul>
<p>The ultimate goal is now clear: creating a self-contained package that could easily reproduce a complete, production-ready REST API backend in a cloud native and scalable setup.</p>
<p><strong>Result</strong></p>
<p>Here’s the result of my work: <a class="reference external" href="https://github.com/alexpacio/python-webapp-boilerplate">https://github.com/alexpacio/python-webapp-boilerplate</a></p>
<p>Although there are a few rough edges and minor aspects that I handled in a superficial way, this serves as an example of how a modern, asynchronous FastAPI backend can be delivered within a single Git repository.
I believe it's a solid boilerplate to start with, and it allowed me to explore new tools like Pulumi, FastAPI, and other recent technologies.</p>
<p><strong>Thoughts</strong></p>
<p>Even though I feel like the entire AWS ecosystem is increasingly filling gaps (perhaps revenue gaps?) with bloat everywhere, I’ve been impressed with how concise, easy to use, develop, and reproduce a project like this can be. From this foundation, you can build a very sophisticated system while keeping everything in one place.
Additionally, you can test your AWS services locally and connect them later by simply using the Helm values file for the infrastructure or the .env file in the root folder for the application properties.</p>
<p>As mentioned, there’s definitely room for several small adjustments to make it work seamlessly, but I think this is a very solid and complete starting point! I may have missed something important, as I dedicated only a small portion of my time to this challenge.</p>
<p>Imagine having a temporary Kubernetes (K8s) namespace just to run your end-to-end (e2e) tests, reproducing the entire AWS PaaS stack and your application in a replicated and horizontally scalable way: you run the tests, collect the report, and then dispose of the environment.</p>
<p>The same approach can be used for your benchmarking needs.</p>
<p>With every change you make to your code, you can potentially test each step in your local cluster, which is automatically initialized in every aspect.</p>
<p>Just focus on your infrastructure and application code, set your environment variable files, and your portable cluster is up and running!</p>
<p><strong>Outcome</strong></p>
<p>I think I’ll continue to work on this. Cloud-native applications that avoid being locked into a specific cloud provider while still being distributed, scalable, and easy to use are possible.
I look forward to building an opinionated version of this soon. Stay tuned!</p>
<p><strong>Contribute!</strong></p>
<p>Feel free to use it as you wish, and let me know if you have any comments.</p>
<p>Cheers!</p>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/hello-world/" class="u-url">Hello world!</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Alessandro Bolletta
            </span></p>
            <p class="dateline">
            <a href="posts/hello-world/" rel="bookmark">
            <time class="published dt-published" datetime="2024-09-21T16:41:03+02:00" itemprop="datePublished" title="2024-09-21 16:41">2024-09-21 16:41</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <p>This is my first post! I'm excited to start sharing tips on backend development, cloud computing, and more.</p>
    </div>
    </article>
</div>



    





         </main><footer id="footer"><p>Contents © 2024         <a href="mailto:alexpacio91%20at%20gmail%20dot%20com">Alessandro Bolletta</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>
    
    

    
    
    
</body>
</html>
