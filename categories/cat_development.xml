<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Alessandro's View (Posts about Development)</title><link>https://alexpacio.github.io/</link><description></description><atom:link href="https://alexpacio.github.io/categories/cat_development.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2025 &lt;a href="mailto:alexpacio91 at gmail dot com"&gt;Alessandro Bolletta&lt;/a&gt; </copyright><lastBuildDate>Mon, 04 Aug 2025 13:44:05 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>The Hidden Costs of Static Linking and Containerization: A Critical Analysis</title><link>https://alexpacio.github.io/posts/hidden-costs-static-linking-containerization/</link><dc:creator>Alessandro Bolletta</dc:creator><description>&lt;section id="statically-linked-programs-are-the-evil"&gt;
&lt;h2&gt;Statically-linked Programs are the evil&lt;/h2&gt;
&lt;p&gt;The trend toward static linking represents a fundamental regression in software engineering principles. By bundling every dependency directly into the executable, we're not just bloating our binaries - we're actively dismantling decades of progress in software modularization. Each statically linked program becomes an island, disconnected from the ecosystem of shared improvements and security updates.&lt;/p&gt;
&lt;p&gt;Consider what happens when a critical vulnerability is discovered in a commonly used library. In a properly designed system using shared libraries, a single system update would protect all applications simultaneously. Instead, with static linking, we must embark on a complex and error-prone process of identifying every affected program, rebuilding each one individually, and ensuring they all get redeployed.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://alexpacio.github.io/posts/hidden-costs-static-linking-containerization/"&gt;Read more…&lt;/a&gt; (7 min remaining to read)&lt;/p&gt;&lt;/section&gt;</description><category>containers</category><category>development</category><category>infrastructure</category><category>security</category><category>static-linking</category><guid>https://alexpacio.github.io/posts/hidden-costs-static-linking-containerization/</guid><pubDate>Sun, 02 Feb 2025 07:00:00 GMT</pubDate></item><item><title>Exchanging messages between processes (or even threads within the same program) using ZeroMQ</title><link>https://alexpacio.github.io/posts/message-exchanges-using-zeromq/</link><dc:creator>Alessandro Bolletta</dc:creator><description>&lt;section id="inter-process-communication-with-zeromq-and-protocol-buffers"&gt;
&lt;h2&gt;Inter-Process Communication with ZeroMQ (and Protocol Buffers)&lt;/h2&gt;
&lt;section id="introduction"&gt;
&lt;h3&gt;Introduction&lt;/h3&gt;
&lt;p&gt;Some may certainly say that, when you are writing so called "daemons" under Linux/Unix OSes or "services" under Windows, you might want to use OS primitives/reuse existing libraries to make your programs communicate each other. And I strongly agree with the point: it is always a good idea to use a well-tested and solid library to implement such fundamental features such as message queues.&lt;/p&gt;
&lt;p&gt;For example, under Linux you can use D-Bus, which allows IPC at scale within the OS scope. Or, in the microservices space, you can leverage on message brokers like RabbitMQ or Kafka to stream your messages through sophisticated routing logic. However, at times you are just looking for something trivial and simple to send and queue messages where at the same time you look for brokerless setup but still you are willing to leverage on some of the features that message queuing systems offer for free with ease. That's where ZeroMQ comes in.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://alexpacio.github.io/posts/message-exchanges-using-zeromq/"&gt;Read more…&lt;/a&gt; (6 min remaining to read)&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;</description><category>C</category><category>golang</category><category>ZeroMQ</category><guid>https://alexpacio.github.io/posts/message-exchanges-using-zeromq/</guid><pubDate>Mon, 27 Jan 2025 18:00:00 GMT</pubDate></item><item><title>Building a Lightweight Node.js Background Job Scheduler: A Practical Solution for Simple Web Applications</title><link>https://alexpacio.github.io/posts/lightweight-nodejs-background-job-scheduler/</link><dc:creator>Alessandro Bolletta</dc:creator><description>&lt;section id="building-a-lightweight-node-js-background-job-scheduler"&gt;
&lt;h2&gt;Building a Lightweight Node.js Background Job Scheduler&lt;/h2&gt;
&lt;p&gt;As developers, we often come across situations where a fully-fledged background job system, with all its bells and whistles, might be overkill for our project needs. This was the case for me when I built a custom background job scheduler in &lt;strong&gt;TypeScript&lt;/strong&gt; and &lt;strong&gt;Node.js&lt;/strong&gt;, designed to handle essential tasks without the overhead of larger, more complex solutions.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://alexpacio.github.io/posts/lightweight-nodejs-background-job-scheduler/"&gt;Read more…&lt;/a&gt; (2 min remaining to read)&lt;/p&gt;&lt;/section&gt;</description><category>Background Jobs</category><category>Docker</category><category>Node.js</category><category>Telegram</category><category>TypeScript</category><guid>https://alexpacio.github.io/posts/lightweight-nodejs-background-job-scheduler/</guid><pubDate>Thu, 10 Oct 2024 12:00:00 GMT</pubDate></item></channel></rss>