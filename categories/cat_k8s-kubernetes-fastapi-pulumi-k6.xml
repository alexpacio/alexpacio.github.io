<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Alessandro Bolletta (Posts about k8s kubernetes fastapi pulumi k6)</title><link>https://alexpacio.github.io/</link><description></description><atom:link href="https://alexpacio.github.io/categories/cat_k8s-kubernetes-fastapi-pulumi-k6.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:alexpacio91 at gmail dot com"&gt;Alessandro Bolletta&lt;/a&gt; </copyright><lastBuildDate>Sun, 22 Sep 2024 13:28:37 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Full-fledged API + e2e tests + benchmark + IaC + Helm charts + more as an (interesting) exercise!</title><link>https://alexpacio.github.io/posts/python-k8s-api/</link><dc:creator>Alessandro Bolletta</dc:creator><description>&lt;p&gt;Last week, I was contacted by a weird "Sr. Talent Scout Specialist" who asked me to create a project for a hiring challenge. The project seemed interesting, so I decided to take it on. At the very least, I would learn something new, which I was eager to explore: Pulumi, k6, FastAPI and some fancy modern things that make you a cool dev!&lt;/p&gt;
&lt;p&gt;The project involved creating a simple REST API in Python, which needed to be packaged with Helm, ready for deployment in a Kubernetes (K8s) cluster, and including all the essential tools required.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Requirements&lt;/strong&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;A Python REST API backend program. The choice of framework was up to me, and it had to include Swagger API documentation and end-to-end (e2e) tests.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A CDK-like deployment script to automate the API’s dependencies: Terraform or Pulumi (for an AWS CDK-like experience). Since I was curious, I chose Pulumi.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Either an AWS account or an automated way to use Localstack, a tool that simulates AWS’s APIs in your local environment.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A Helm package to deploy the Kubernetes cluster.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Kubernetes manifests that addressed the automated scalability of the REST API backend and included the necessary health checks.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scripts to tie everything together, making the cluster reproducible by following a series of steps outlined in a README file.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The ultimate goal is now clear: creating a self-contained package that could easily reproduce a complete, production-ready REST API backend in a cloud native and scalable setup.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Result&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Here’s the result of my work: &lt;a class="reference external" href="https://github.com/alexpacio/python-webapp-boilerplate"&gt;https://github.com/alexpacio/python-webapp-boilerplate&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Although there are a few rough edges and minor aspects that I handled in a superficial way, this serves as an example of how a modern, asynchronous FastAPI backend can be delivered within a single Git repository.
I believe it's a solid boilerplate to start with, and it allowed me to explore new tools like Pulumi, FastAPI, and other recent technologies.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Thoughts&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Even though I feel like the entire AWS ecosystem is increasingly filling gaps (perhaps revenue gaps?) with bloat everywhere, I’ve been impressed with how concise, easy to use, develop, and reproduce a project like this can be. From this foundation, you can build a very sophisticated system while keeping everything in one place.
Additionally, you can test your AWS services locally and connect them later by simply using the Helm values file for the infrastructure or the .env file in the root folder for the application properties.
As mentioned, there’s definitely room for several small adjustments to make it work seamlessly, but I think this is a very solid and complete starting point! I may have missed something important, as I dedicated only a small portion of my time to this challenge.
Imagine having a temporary Kubernetes (K8s) namespace just to run your end-to-end (e2e) tests, reproducing the entire AWS PaaS stack and your application in a replicated and horizontally scalable way: you run the tests, collect the report, and then dispose of the environment.
The same approach can be used for your benchmarking needs.
With every change you make to your code, you can potentially test each step in your local cluster, which is automatically initialized in every aspect.
Just focus on your infrastructure and application code, set your environment variable files, and your portable cluster is up and running!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Outcome&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I think I’ll continue to work on this. Cloud-native applications that avoid being locked into a specific cloud provider while still being distributed, scalable, and easy to use are possible.
I look forward to building an opinionated version of this soon. Stay tuned!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Contribute!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Feel free to use it as you wish, and let me know if you have any comments.&lt;/p&gt;
&lt;p&gt;Cheers!&lt;/p&gt;</description><guid>https://alexpacio.github.io/posts/python-k8s-api/</guid><pubDate>Sun, 22 Sep 2024 12:19:03 GMT</pubDate></item></channel></rss>